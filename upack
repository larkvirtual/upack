#!/bin/bash
# Using bash just for associative arrays
# bash version must be >= 4, as bash version 3 can't handle 'declare -A map'
# construction

DRYRUN=0            # boolean variable
FORCEY=""           #  string variable
UNPROCPKGS=""       #  string variable
PROCESSEDPKGS=""    #  string variable

usage() {
    echo "Usage: install|remove [-y | --dry-run] command1 ..."
    echo "Usage: up|dup      # update / full system (including kernel) update"
    echo "Usage: up|dup [-y] # for Debian, openSUSE, RHEL/CentOS/Fedora"
    echo "Usage: --list-commands"
    echo "Usage: --list-supported-envs"
    echo "Usage: --version"
}

empty() {
    return
}

debian_up() {
    apt-get update && apt-get upgrade $FORCEY && \
    apt-get autoremove $FORCEY && apt-get clean
}

debian_dup() {
    apt-get update && apt-get dist-upgrade $FORCEY && \
    apt-get autoremove $FORCEY && apt-get clean
}

altlinux_up() {
    apt-get update && apt-get upgrade && apt-get clean
}

altlinux_dup() {
    apt-get update && apt-get dist-upgrade && update-kernel && \
    remove-old-kernels && apt-get clean
}

fedora_dup() {
    dnf update $FORCEY
}

centos_dup() {
    yum update $FORCEY
}

pacman_dup() {
    pacman -Syu
}

freebsd_up() {
    echo "Updating installed packages..."
    pkg upgrade && pkg autoremove && pkg clean
}

freebsd_dup() {
    freebsd_up
    echo "Updating base system with kernel..."
    echo "First install is for userland/kernel, Second is for kernel/userland, Third to make sure install queue is empty"
    freebsd-update fetch && freebsd-update install && freebsd-update install && freebsd-update install
}

suse_up() {
    zypper up $FORCEY && zypper ps -s
}

suse_dup() {
    zypper dup $FORCEY && zypper ps -s
}

solaris_dup() {
    pkg update
}

# $1 - environment name
up() {
    if [ $1 = debian ]; then
        debian_up
    elif [ $1 = fedora ]; then
        fedora_dup # this is not typo, fedora_up === fedora_dup
        # as there is only way to do fedora_dup only?
    elif [ $1 = centos ]; then
        centos_dup # this is not typo, centos_up === centos_dup
        # -""-
    elif [ $1 = pacman ]; then
        pacman_dup # this is not typo, pacman_up === pacman_dup
        # -""-
    elif [ $1 = altlinux ]; then
        altlinux_up
    elif [ $1 = freebsd ]; then
        freebsd_up
    elif [ $1 = suse ]; then
        suse_up
    elif [ $1 = solaris ]; then
        solaris_dup; # this is not typo, solaris_up === solaris_dup
    else echo "NYI"; exit 1; fi
}

# $1 - environment name
dup() {
    if [ $1 = debian ]; then debian_dup
    elif [ $1 = fedora ]; then fedora_dup
    elif [ $1 = centos ]; then centos_dup
    elif [ $1 = pacman ]; then pacman_dup
    elif [ $1 = altlinux ]; then altlinux_dup
    elif [ $1 = freebsd ]; then freebsd_dup
    elif [ $1 = suse ]; then suse_dup
    elif [ $1 = solaris ]; then solaris_dup
    else echo "NYI"; exit 1; fi
}

detect_env() {
    grep -q "[Dd]ebian" /etc/os-release 2> /dev/null
    if [ $? = 0 ]; then echo debian; return; fi

    grep -q "os/illumos/dyson/apt" /etc/apt/sources.list 2> /dev/null
    if [ $? = 0 ]; then echo debian; return; fi

    grep -q "ID=\"centos\"" /etc/os-release 2> /dev/null
    if [ $? = 0 ]; then echo centos; return; fi

    grep -q "[Ff]edora" /etc/os-release 2> /dev/null
    if [ $? = 0 ]; then echo fedora; return; fi

    grep -q "manjaro" /etc/os-release 2> /dev/null
    if [ $? = 0 ]; then echo pacman; return; fi

    grep -q "altlinux" /etc/os-release 2> /dev/null
    if [ $? = 0 ]; then echo altlinux; return; fi

    grep -q "suse" /etc/os-release 2> /dev/null
    if [ $? = 0 ]; then echo suse; return; fi

    theuname=`uname`
    if [ "$theuname" = "FreeBSD" ]; then echo freebsd; return; fi
    if [ "$theuname" = "SunOS" ]; then echo solaris; return; fi

    echo ""
}

list_supported() {
    echo "Debian (at least 8)"
    echo "Ubuntu (at least 16.04)"
    echo "Fedora (at least 24)"
    echo "CentOS (at least 7)"
    echo "Dyson (at least Dufay)"
    echo "Manjaro (at least 17.0)"
    echo "AltLinux (at least 8)"
    echo "FreeBSD (at least 11)"
    echo "openSUSE (at least Leap 42.2)"
    echo "Solaris (at least 11.3)"
}

en=$(detect_env)
if [ x$en = x ]; then
    echo "Unsupported OS/Environment. Patch me and merge request or contact support"
    exit 1
fi

declare -A map
# touples command=package should not be listed
if [ $en = debian ]; then
    map[7z]=p7zip-full
    map[7za]=p7zip-full
    #map[7zr]=p7zip # for command with absence packages for all environments will be no support
    map[qmake-qt4]=qt4-make
elif [ $en = redhat ] || [ $en = fedora ] || [ $en = centos ]; then
    map[sshfs]=fuse-sshfs
    map[qtcreator]=qt-creator
    map[7z]=p7zip-plugins
    map[7za]=p7zip
    #map[7zr]=n/a
    map[g++]=gcc-c++
    map[qmake-qt4]=qt-devel
    map[gnat]=gcc-gnat
    map[wireshark]=wireshark-gtk
elif [ $en = altlinux ]; then
    map[sshfs]=fuse-sshfs
    map[qtcreator]=qt-creator
    map[7z]=p7zip
    map[7za]=p7zip-standalone
    map[g++]=gcc5-c++
    map[qmake-qt4]=qt-devel
    map[gnat]=gcc5-gnat
    map[wireshark]=wireshark-gtk+
elif [ $en = pacman ]; then
    map[7z]=p7zip
    map[7za]=p7zip
    map[g++]=gcc
    map[qmake-qt4]=qt4
    map[gnat]=gcc-ada
    map[wireshark]=wireshark-gtk
elif [ $en = freebsd ]; then
    map[sshfs]=fuse-sshfs
    map[7z]=p7zip
    map[7za]=p7zip
elif [ $en = suse ]; then
    map[7z]=p7zip
    map[7za]=p7zip
    map[g++]=gcc-c++
    map[gnat]=gcc-ada
    map[qmake-qt4]=libqt4-devel
    map[qtcreator]=libqt5-creator
elif [ $en = solaris ]; then
    map[7z]=p7zip
    map[7za]=p7zip
    map[g++]=gcc-c++
else
    echo NYI
    exit 1
fi;

if [ $# = 1 ]; then
    if [ $1 = --list-commands ]; then for i in "${!map[@]}"; do echo $i; done; exit 0; fi
    if [ $1 = --list-supported-envs ]; then list_supported; exit 0; fi
    if [ $1 = --version ]; then
        echo "$0 version $(if [ -f /usr/bin/upack.version ]; then \
            cat /usr/bin/upack.version; else echo \"unknown\"; fi)"; exit 0; fi
    if [ $1 = up ]; then up $en; exit 0; fi
    if [ $1 = dup ]; then dup $en; exit 0; fi
elif [ $# = 2 ] && [ $1 = up ] && [ $2 = "-y" ]; then
    FORCEY=$2
    up $en
    exit 0
elif [ $# = 2 ] && [ $1 = dup ] && [ $2 = "-y" ]; then
    FORCEY=$2
    dup $en
    exit 0
fi

if [ $# -ge 1 ]; then
    if [ $1 != install ] && [ $1 != remove ] && \
       [ $1 != up ] && [ $1 != dup ]; then
        usage;
        exit 0;
    fi
else
    usage;
    exit 0;
fi

cmd_extra=""
if [ $en = debian ]; then
    cmd="apt-get $1"
    if [ $1 = remove ]; then
        cmd_extra="apt-get autoremove"
    fi
elif [ $en = altlinux ]; then
    cmd="apt-get $1"
elif [ $en = fedora ]; then
    cmd="dnf $1"
    if [ $1 = remove ]; then
        cmd_extra="dnf autoremove"
    fi
elif [ $en = centos ]; then
    cmd="yum $1"
    if [ $1 = remove ]; then
        cmd_extra="yum autoremove"
    fi
elif [ $en = pacman ]; then
    if [ $1 = install ]; then
        cmd="pacman -S"
    elif [ $1 = remove ]; then
        cmd="pacman -Rs"
    else
        echo "Internal error"
        exit 1
    fi
elif [ $en = freebsd ]; then
    if [ $1 = install ]; then
        cmd="pkg install"
    elif [ $1 = remove ]; then
        cmd="pkg delete"
        cmd_extra="pkg autoremove"
    else
        echo "Internal error"
        exit 1
    fi
elif [ $en = suse ]; then
    cmd="zypper $1"
elif [ $en = solaris ]; then
    if [ $1 = install ]; then
        cmd="pkg install"
    elif [ $1 = remove ]; then
        cmd="pkg uninstall"
    else
        echo "Internal error"
        exit 1
    fi
else
    echo "Internal error: add check for a new environment"
    exit 1
fi

for i in $@; do
    if [ $i = "-y" ]; then FORCEY=$i;
    elif [ $i = "--dry-run" ]; then DRYRUN=1;
    elif [ $i = $1 ]; then empty; # just do nothing, needed to skip first argument
    else
        UNPROCPKGS="$i $UNPROCPKGS"
    fi
done

for i in $UNPROCPKGS; do
    if ! [ ${map[$i]+_} ]; then
        # there is no such key in map, using directly
        # (in hope command=package for all environments)
        PROCESSEDPKGS="$i $PROCESSEDPKGS"
    else
        # substitute command $i using map
        PROCESSEDPKGS="${map[$i]} $PROCESSEDPKGS"
    fi
done

if [ x$FORCEY != x ]; then
    if [ $en != pacman ]; then
        # FreeBSD's pkg, openSUSE zypper allows -y only after first argument
        # others tools does, but let's put -y first anyways
        finalCmd="$cmd -y $PROCESSEDPKGS"
    else
        echo "NOTE: pacman doesn't support -y key (yet), ignoring -y"
        finalCmd="$cmd $PROCESSEDPKGS"
    fi
    if [ ! -z "$cmd_extra" ]; then cmd_extra="$cmd_extra -y"; fi
else
    finalCmd="$cmd $PROCESSEDPKGS"
fi

if [ $DRYRUN = 1 ]; then
    echo "$finalCmd"
    if [ ! -z "$cmd_extra" ]; then echo "$cmd_extra"; fi
    exit 0;
fi

$finalCmd
if [ ! -z "$cmd_extra" ]; then
    $cmd_extra
fi
